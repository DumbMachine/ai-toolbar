{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "hello-world",
  "type": "registry:block",
  "title": "Hello World",
  "description": "A simple hello world component.",
  "dependencies": [
    "bippy"
  ],
  "files": [
    {
      "path": "registry/new-york/blocks/toolbar/ai-toolbar.tsx",
      "content": "\"use client\";\n\nimport { Check, GitBranch, MousePointer2 } from \"lucide-react\";\nimport { useCallback, useMemo, useRef, useState, useEffect } from \"react\";\n\nimport { useDrawSelect, useSingleSelect } from \"./hooks/use-bippy\";\n\n// TypeScript interfaces\ninterface FiberInfo {\n\tcomponentName: string;\n\tprops: Record<string, unknown>;\n\tsource?: {\n\t\tfileName: string;\n\t\tlineNumber: number;\n\t\tcolumnNumber: number;\n\t} | null;\n}\n\ninterface AnnotationData {\n\telement?: Element;\n\telements?: Element[];\n\trect: DOMRect | SelectionRect;\n\tfiberInfo: FiberInfo | FiberInfo[] | null;\n\tid: number;\n\tmode?: string;\n}\n\ninterface Position {\n\tx: number;\n\ty: number;\n}\n\ninterface SelectionRect {\n\tleft: number;\n\ttop: number;\n\twidth: number;\n\theight: number;\n}\n\ninterface HighlightOverlayProps {\n\trect: DOMRect | SelectionRect | null;\n\tcolor?: \"primary\" | \"secondary\";\n\tstyle?: \"dashed\" | \"solid\";\n}\n\ninterface SelectionRectangleProps {\n\tstartPos: Position | null;\n\tcurrentPos: Position | null;\n}\n\ninterface ToastProps {\n\tmessage: string;\n\tcount?: number;\n}\n\n// Helper function from hooks\nconst getSelectionRect = (\n\tstart: Position | null,\n\tend: Position | null,\n): SelectionRect | null => {\n\tif (!start || !end) return null;\n\treturn {\n\t\tleft: Math.min(start.x, end.x),\n\t\ttop: Math.min(start.y, end.y),\n\t\twidth: Math.abs(end.x - start.x),\n\t\theight: Math.abs(end.y - start.y),\n\t};\n};\n\nconst annotationToPrompt = (annotation: AnnotationData, idx?: number) => {\n\tconst fiberInfo = Array.isArray(annotation.fiberInfo)\n\t\t? annotation.fiberInfo[0]\n\t\t: annotation.fiberInfo;\n\n\tconsole.log({ fiberInfo });\n\tconst componentName = fiberInfo?.componentName || \"unknown\";\n\tconst source = fiberInfo?.source;\n\tconst props = fiberInfo?.props;\n\n\tlet contextInfo = `[Component: <${componentName}>]`;\n\n\tif (source) {\n\t\tcontextInfo += `\\n[Location: ${source.fileName}:${source.lineNumber}:${source.columnNumber}]`;\n\t}\n\n\tif (props && Object.keys(props).length > 0) {\n\t\tconst propsList = Object.entries(props)\n\t\t\t.slice(0, 5)\n\t\t\t.map(\n\t\t\t\t([key, val]) => `${key}=${typeof val === \"string\" ? `\"${val}\"` : val}`,\n\t\t\t)\n\t\t\t.join(\", \");\n\t\tcontextInfo += `\\n[Props: ${propsList}${Object.keys(props).length > 5 ? \"...\" : \"\"}]`;\n\t}\n\treturn `\n<referenced_element>\n${contextInfo}\n</referenced_element>\n\t`;\n};\n\nconst Toast: React.FC<ToastProps> = ({ message, count }) => {\n\treturn (\n\t\t<div className=\"fixed top-8 left-1/2 -translate-x-1/2 z-1000001 animate-in fade-in slide-in-from-top-4 duration-300\">\n\t\t\t<div className=\"bg-card border rounded-xl shadow-2xl px-6 py-4 flex items-center gap-3 min-w-[300px]\">\n\t\t\t\t<div className=\"shrink-0 w-8 h-8 bg-primary/10 rounded-full flex items-center justify-center\">\n\t\t\t\t\t<Check className=\"w-5 h-5 text-primary\" />\n\t\t\t\t</div>\n\t\t\t\t<div className=\"flex-1\">\n\t\t\t\t\t<p className=\"text-sm font-medium text-foreground\">{message}</p>\n\t\t\t\t\t{count && count > 1 && (\n\t\t\t\t\t\t<p className=\"text-xs text-muted-foreground mt-0.5\">\n\t\t\t\t\t\t\t{count} annotations copied\n\t\t\t\t\t\t</p>\n\t\t\t\t\t)}\n\t\t\t\t</div>\n\t\t\t</div>\n\t\t</div>\n\t);\n};\n\nconst HighlightOverlay: React.FC<HighlightOverlayProps> = ({\n\trect,\n\tcolor = \"primary\",\n\tstyle = \"dashed\",\n}) => {\n\tif (!rect) return null;\n\n\tconst colorMap: Record<string, string> = {\n\t\tprimary: \"border-primary bg-primary/10\",\n\t\tsecondary: \"border-secondary bg-secondary/10\",\n\t};\n\n\treturn (\n\t\t<div\n\t\t\tclassName={`fixed pointer-events-none z-999998 transition-all ${colorMap[color]}`}\n\t\t\tstyle={{\n\t\t\t\tleft: `${rect.left}px`,\n\t\t\t\ttop: `${rect.top}px`,\n\t\t\t\twidth: `${rect.width}px`,\n\t\t\t\theight: `${rect.height}px`,\n\t\t\t\tborderWidth: \"2px\",\n\t\t\t\tborderStyle: style,\n\t\t\t}}\n\t\t/>\n\t);\n};\n\nconst SelectionRectangle: React.FC<SelectionRectangleProps> = ({\n\tstartPos,\n\tcurrentPos,\n}) => {\n\tconst rect = useMemo(\n\t\t() => getSelectionRect(startPos, currentPos),\n\t\t[startPos, currentPos],\n\t);\n\n\tif (!rect) return null;\n\n\treturn (\n\t\t<div\n\t\t\tclassName=\"fixed pointer-events-none z-999998 border-2 border-dashed border-purple-500 bg-purple-500/10\"\n\t\t\tstyle={{\n\t\t\t\tleft: `${rect.left}px`,\n\t\t\t\ttop: `${rect.top}px`,\n\t\t\t\twidth: `${rect.width}px`,\n\t\t\t\theight: `${rect.height}px`,\n\t\t\t}}\n\t\t/>\n\t);\n};\n\nconst AIAnnotationToolbar = () => {\n\tconst [mode, setMode] = useState<\n\t\tnull | \"single-select\" | \"multi-comment\" | \"draw-select\"\n\t>(null);\n\t\n\t// Initialize position to bottom center (like Vercel toolbar)\n\tconst [position, setPosition] = useState({ x: 0, y: 0 });\n\tconst [isDragging, setIsDragging] = useState(false);\n\tconst [dragOffset, setDragOffset] = useState({ x: 0, y: 0 });\n\tconst [annotations, setAnnotations] = useState<AnnotationData[]>([]);\n\tconst [showToast, setShowToast] = useState(false);\n\tconst [toastMessage, setToastMessage] = useState(\"\");\n\tconst [annotationCount, setAnnotationCount] = useState(0);\n\n\tconst toolbarRef = useRef<HTMLDivElement>(null);\n\tconst toastTimeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n\t// Set initial position to bottom center\n\tuseEffect(() => {\n\t\tif (typeof window !== \"undefined\" && toolbarRef.current) {\n\t\t\tconst updatePosition = () => {\n\t\t\t\tconst toolbarRect = toolbarRef.current?.getBoundingClientRect();\n\t\t\t\tif (toolbarRect) {\n\t\t\t\t\tconst x = window.innerWidth / 2 - toolbarRect.width / 2;\n\t\t\t\t\tconst y = window.innerHeight - toolbarRect.height - 32; // 32px from bottom\n\t\t\t\t\tsetPosition({ x, y });\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// Set initial position after component mounts\n\t\t\tconst timer = setTimeout(updatePosition, 0);\n\t\t\t\n\t\t\t// Update position on window resize\n\t\t\twindow.addEventListener('resize', updatePosition);\n\t\t\t\n\t\t\treturn () => {\n\t\t\t\tclearTimeout(timer);\n\t\t\t\twindow.removeEventListener('resize', updatePosition);\n\t\t\t};\n\t\t}\n\t}, []);\n\n\tconst tools = useMemo(\n\t\t() => [\n\t\t\t{\n\t\t\t\tid: \"single-select\" as const,\n\t\t\t\ticon: MousePointer2,\n\t\t\t\tlabel: \"Single Select\",\n\t\t\t\ttooltip: \"Click elements to copy context\",\n\t\t\t},\n\t\t\t{\n\t\t\t\tid: \"multi-comment\" as const,\n\t\t\t\ticon: GitBranch,\n\t\t\t\tlabel: \"Multi Comment\",\n\t\t\t\ttooltip: \"Add multiple annotations\",\n\t\t\t},\n\t\t\t// {\n\t\t\t// \tid: \"draw-select\" as const,\n\t\t\t// \ticon: Box,\n\t\t\t// \tlabel: \"Draw Select\",\n\t\t\t// \ttooltip: \"Draw rectangle to copy context\",\n\t\t\t// },\n\t\t],\n\t\t[],\n\t);\n\n\tconst copyToClipboard = useCallback(async (text: string) => {\n\t\ttry {\n\t\t\tawait navigator.clipboard.writeText(text);\n\t\t\treturn true;\n\t\t} catch (err) {\n\t\t\tconsole.error(\"Failed to copy:\", err);\n\t\t\treturn false;\n\t\t}\n\t}, []);\n\n\tconst showToastNotification = useCallback(\n\t\t(message: string, count: number = 1) => {\n\t\t\tif (toastTimeoutRef.current) {\n\t\t\t\tclearTimeout(toastTimeoutRef.current);\n\t\t\t}\n\n\t\t\tsetToastMessage(message);\n\t\t\tsetAnnotationCount(count);\n\t\t\tsetShowToast(true);\n\n\t\t\ttoastTimeoutRef.current = setTimeout(() => {\n\t\t\t\tsetShowToast(false);\n\t\t\t}, 3000);\n\t\t},\n\t\t[],\n\t);\n\n\tconst handleAnnotate = useCallback(\n\t\tasync (annotationData: AnnotationData) => {\n\t\t\tconst newAnnotation: AnnotationData = {\n\t\t\t\t...annotationData,\n\t\t\t\tmode,\n\t\t\t};\n\n\t\t\tif (mode === \"multi-comment\") {\n\t\t\t\tsetAnnotations((prev) => [...prev, newAnnotation]);\n\t\t\t} else {\n\t\t\t\t// Single select or draw select - copy immediately\n\t\t\t\tconst contextText = annotationToPrompt(newAnnotation);\n\t\t\t\tconst success = await copyToClipboard(contextText);\n\n\t\t\t\tif (success) {\n\t\t\t\t\tshowToastNotification(\"Context copied to clipboard!\");\n\t\t\t\t}\n\n\t\t\t\t// Clear after a brief highlight\n\t\t\t\tsetTimeout(() => {\n\t\t\t\t\tsetAnnotations([]);\n\t\t\t\t\tsetMode(null);\n\t\t\t\t}, 500);\n\t\t\t}\n\t\t},\n\t\t[mode, copyToClipboard, showToastNotification],\n\t);\n\n\tconst handleModeChange = useCallback(\n\t\tasync (newMode: typeof mode) => {\n\t\t\t// If clicking multi-comment while in multi-comment mode with annotations\n\t\t\tif (\n\t\t\t\tnewMode === \"multi-comment\" &&\n\t\t\t\tmode === \"multi-comment\" &&\n\t\t\t\tannotations.length > 0\n\t\t\t) {\n\t\t\t\t// Copy all annotations\n\t\t\t\tconst contextText = annotations\n\t\t\t\t\t.map((ann, idx) => annotationToPrompt(ann, idx + 1))\n\t\t\t\t\t.join(\"\\n---\\n\\n\");\n\n\t\t\t\tconst success = await copyToClipboard(contextText);\n\n\t\t\t\tif (success) {\n\t\t\t\t\tshowToastNotification(\n\t\t\t\t\t\t\"All contexts copied to clipboard!\",\n\t\t\t\t\t\tannotations.length,\n\t\t\t\t\t);\n\t\t\t\t}\n\n\t\t\t\t// Clear annotations\n\t\t\t\tsetAnnotations([]);\n\t\t\t\tsetMode(null);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (newMode === mode) {\n\t\t\t\tsetMode(null);\n\t\t\t\tsetAnnotations([]);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tsetMode(newMode);\n\t\t\tsetAnnotations([]);\n\t\t},\n\t\t[mode, annotations, copyToClipboard, showToastNotification],\n\t);\n\n\t// Single select mode\n\tconst { element: singleElement, rect: singleRect } = useSingleSelect({\n\t\tenabled: mode === \"single-select\",\n\t\tonAnnotate: handleAnnotate,\n\t});\n\n\t// Multi comment mode\n\tconst { element: multiElement, rect: multiRect } = useSingleSelect({\n\t\tenabled: mode === \"multi-comment\",\n\t\tonAnnotate: handleAnnotate,\n\t});\n\n\t// Draw select mode\n\tconst { isDrawing, startPos, currentPos, selectedElements } = useDrawSelect({\n\t\tenabled: mode === \"draw-select\",\n\t\tonAnnotate: handleAnnotate,\n\t});\n\n\t// Toolbar dragging handlers\n\tconst handleMouseDown = useCallback((e: React.MouseEvent) => {\n\t\tconst target = e.target as Element;\n\t\tif (target.closest(\".drag-handle\")) {\n\t\t\te.preventDefault();\n\t\t\tsetIsDragging(true);\n\t\t\tif (toolbarRef.current) {\n\t\t\t\tconst rect = toolbarRef.current.getBoundingClientRect();\n\t\t\t\tsetDragOffset({\n\t\t\t\t\tx: e.clientX - rect.left,\n\t\t\t\t\ty: e.clientY - rect.top,\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\t}, []);\n\n\tconst handleMouseMove = useCallback((e: MouseEvent) => {\n\t\tif (isDragging) {\n\t\t\te.preventDefault();\n\t\t\tconst newX = e.clientX - dragOffset.x;\n\t\t\tconst newY = e.clientY - dragOffset.y;\n\t\t\t\n\t\t\t// Optional: Add bounds checking to keep toolbar on screen\n\t\t\tconst maxX = window.innerWidth - (toolbarRef.current?.offsetWidth || 0);\n\t\t\tconst maxY = window.innerHeight - (toolbarRef.current?.offsetHeight || 0);\n\t\t\t\n\t\t\tsetPosition({\n\t\t\t\tx: Math.max(0, Math.min(newX, maxX)),\n\t\t\t\ty: Math.max(0, Math.min(newY, maxY)),\n\t\t\t});\n\t\t}\n\t}, [isDragging, dragOffset]);\n\n\tconst handleMouseUp = useCallback(() => {\n\t\tsetIsDragging(false);\n\t}, []);\n\n\t// Add global mouse event listeners for dragging\n\tuseEffect(() => {\n\t\tif (isDragging) {\n\t\t\tdocument.addEventListener('mousemove', handleMouseMove);\n\t\t\tdocument.addEventListener('mouseup', handleMouseUp);\n\t\t\t\n\t\t\treturn () => {\n\t\t\t\tdocument.removeEventListener('mousemove', handleMouseMove);\n\t\t\t\tdocument.removeEventListener('mouseup', handleMouseUp);\n\t\t\t};\n\t\t}\n\t}, [isDragging, handleMouseMove, handleMouseUp]);\n\n\treturn (\n\t\t<>\n\t\t\t{/* Toast Notification */}\n\t\t\t{showToast && <Toast message={toastMessage} count={annotationCount} />}\n\n\t\t\t{/* Floating Toolbar */}\n\t\t\t<div\n\t\t\t\trole={\"toolbar\"}\n\t\t\t\tref={toolbarRef}\n\t\t\t\tclassName=\"ai-toolbar-container fixed z-1000000\"\n\t\t\t\tstyle={{\n\t\t\t\t\tleft: `${position.x}px`,\n\t\t\t\t\ttop: `${position.y}px`,\n\t\t\t\t\tcursor: isDragging ? \"grabbing\" : \"default\",\n\t\t\t\t\tuserSelect: \"none\", // Prevent text selection during drag\n\t\t\t\t}}\n\t\t\t\tonMouseDown={handleMouseDown}\n\t\t\t>\n\t\t\t\t<div className=\"bg-card/95 backdrop-blur-xl rounded-2xl border shadow-2xl p-2\">\n\t\t\t\t\t<div className=\"flex items-center gap-1\">\n\t\t\t\t\t\t{/* Left drag handle */}\n\t\t\t\t\t\t<div className=\"drag-handle cursor-grab active:cursor-grabbing px-2 py-2 hover:bg-accent rounded-lg transition-colors\">\n\t\t\t\t\t\t\t<div className=\"flex flex-col gap-1\">\n\t\t\t\t\t\t\t\t<div className=\"w-1 h-1 bg-muted-foreground/50 rounded-full\" />\n\t\t\t\t\t\t\t\t<div className=\"w-1 h-1 bg-muted-foreground/50 rounded-full\" />\n\t\t\t\t\t\t\t\t<div className=\"w-1 h-1 bg-muted-foreground/50 rounded-full\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\n\t\t\t\t\t\t{/* Comment counter (multi-comment mode) */}\n\t\t\t\t\t\t{mode === \"multi-comment\" && annotations.length > 0 && (\n\t\t\t\t\t\t\t<div className=\"px-3 py-2 bg-primary/10 rounded-lg border border-primary/20\">\n\t\t\t\t\t\t\t\t<span className=\"text-primary text-sm font-medium\">\n\t\t\t\t\t\t\t\t\t{annotations.length} selected\n\t\t\t\t\t\t\t\t</span>\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t)}\n\n\t\t\t\t\t\t{/* Mode selection buttons */}\n\t\t\t\t\t\t{tools.map((tool) => {\n\t\t\t\t\t\t\tconst Icon = tool.icon;\n\t\t\t\t\t\t\tconst isActive = mode === tool.id;\n\t\t\t\t\t\t\tconst showCopyIndicator =\n\t\t\t\t\t\t\t\tisActive &&\n\t\t\t\t\t\t\t\ttool.id === \"multi-comment\" &&\n\t\t\t\t\t\t\t\tannotations.length > 0;\n\n\t\t\t\t\t\t\treturn (\n\t\t\t\t\t\t\t\t<button\n\t\t\t\t\t\t\t\t\ttype={\"button\"}\n\t\t\t\t\t\t\t\t\tkey={tool.id}\n\t\t\t\t\t\t\t\t\tonClick={() => handleModeChange(tool.id)}\n\t\t\t\t\t\t\t\t\tclassName={`p-3 rounded-lg transition-all group relative ${\n\t\t\t\t\t\t\t\t\t\tisActive ? \"bg-accent shadow-lg\" : \"hover:bg-accent/50\"\n\t\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t\t>\n\t\t\t\t\t\t\t\t\t<Icon\n\t\t\t\t\t\t\t\t\t\tclassName={`w-5 h-5 transition-colors ${\n\t\t\t\t\t\t\t\t\t\t\tisActive\n\t\t\t\t\t\t\t\t\t\t\t\t? \"text-primary\"\n\t\t\t\t\t\t\t\t\t\t\t\t: \"text-muted-foreground group-hover:text-foreground\"\n\t\t\t\t\t\t\t\t\t\t}`}\n\t\t\t\t\t\t\t\t\t/>\n\t\t\t\t\t\t\t\t\t<div className=\"absolute -bottom-10 left-1/2 -translate-x-1/2 px-3 py-1.5 bg-popover text-xs text-popover-foreground rounded-lg opacity-0 group-hover:opacity-100 transition-opacity pointer-events-none whitespace-nowrap border z-50 shadow-md\">\n\t\t\t\t\t\t\t\t\t\t{showCopyIndicator ? \"Click to copy all\" : tool.tooltip}\n\t\t\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t\t\t\t{isActive && (\n\t\t\t\t\t\t\t\t\t\t<div className=\"absolute -bottom-1 left-1/2 -translate-x-1/2 w-1 h-1 bg-primary rounded-full\" />\n\t\t\t\t\t\t\t\t\t)}\n\t\t\t\t\t\t\t\t</button>\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t})}\n\n\t\t\t\t\t\t{/* Right drag handle */}\n\t\t\t\t\t\t<div className=\"drag-handle cursor-grab active:cursor-grabbing px-2 py-2 hover:bg-accent rounded-lg transition-colors\">\n\t\t\t\t\t\t\t<div className=\"flex flex-col gap-1\">\n\t\t\t\t\t\t\t\t<div className=\"w-1 h-1 bg-muted-foreground/50 rounded-full\" />\n\t\t\t\t\t\t\t\t<div className=\"w-1 h-1 bg-muted-foreground/50 rounded-full\" />\n\t\t\t\t\t\t\t\t<div className=\"w-1 h-1 bg-muted-foreground/50 rounded-full\" />\n\t\t\t\t\t\t\t</div>\n\t\t\t\t\t\t</div>\n\t\t\t\t\t</div>\n\t\t\t\t</div>\n\t\t\t</div>\n\n\t\t\t{/* Hover highlights */}\n\t\t\t{mode === \"single-select\" && singleRect && (\n\t\t\t\t<HighlightOverlay rect={singleRect} />\n\t\t\t)}\n\n\t\t\t{mode === \"multi-comment\" && multiRect && (\n\t\t\t\t<HighlightOverlay rect={multiRect} />\n\t\t\t)}\n\n\t\t\t{/* Persistent annotation highlights */}\n\t\t\t{annotations.map((annotation) => (\n\t\t\t\t<HighlightOverlay\n\t\t\t\t\tkey={annotation.id}\n\t\t\t\t\trect={annotation.rect}\n\t\t\t\t\tcolor=\"secondary\"\n\t\t\t\t\tstyle=\"solid\"\n\t\t\t\t/>\n\t\t\t))}\n\n\t\t\t{/* Draw selection rectangle */}\n\t\t\t{isDrawing && (\n\t\t\t\t<SelectionRectangle startPos={startPos} currentPos={currentPos} />\n\t\t\t)}\n\n\t\t\t{/* Selected elements highlights */}\n\t\t\t{selectedElements.map((el, idx) => (\n\t\t\t\t<HighlightOverlay\n\t\t\t\t\tkey={`selected-${idx}`}\n\t\t\t\t\trect={el.getBoundingClientRect()}\n\t\t\t\t\tcolor=\"secondary\"\n\t\t\t\t/>\n\t\t\t))}\n\t\t</>\n\t);\n};\n\nexport default AIAnnotationToolbar;",
      "type": "registry:file",
      "target": "components/ai-toolbar/ai-toolbar.tsx"
    },
    {
      "path": "registry/new-york/blocks/toolbar/hooks/use-bippy.ts",
      "content": "import {\n\tgetDisplayName,\n\tgetFiberFromHostInstance,\n\tgetLatestFiber,\n} from \"bippy\";\nimport { getFiberSource } from \"bippy/dist/source.js\";\nimport { useEffect, useRef, useState } from \"react\";\n\n// TypeScript interfaces\ninterface FiberInfo {\n\tcomponentName: string;\n\tprops: Record<string, unknown>;\n\tsource?: {\n\t\tfileName: string;\n\t\tlineNumber: number;\n\t\tcolumnNumber: number;\n\t} | null;\n}\n\ninterface Position {\n\tx: number;\n\ty: number;\n}\n\ninterface SelectionRect {\n\tleft: number;\n\ttop: number;\n\twidth: number;\n\theight: number;\n}\n\ninterface AnnotationData {\n\telement?: Element;\n\telements?: Element[];\n\trect: DOMRect | SelectionRect;\n\tfiberInfo: FiberInfo | FiberInfo[] | null;\n\tid: number;\n}\n\ninterface HookProps {\n\tenabled: boolean;\n\tonAnnotate?: (data: AnnotationData) => void;\n}\n\nconst throttle = (fn: (...args: unknown[]) => void, wait: number) => {\n\tlet timeout: NodeJS.Timeout | null = null;\n\treturn function (this: unknown, ...args: unknown[]) {\n\t\tif (!timeout) {\n\t\t\ttimeout = setTimeout(() => {\n\t\t\t\tfn.apply(this, args);\n\t\t\t\ttimeout = null;\n\t\t\t}, wait);\n\t\t}\n\t};\n};\n\n// Use actual bippy implementation for fiber detection\nconst getFiberInfo = async (element: Element): Promise<FiberInfo | null> => {\n\tif (!element) return null;\n\n\ttry {\n\t\tconst fiber = getFiberFromHostInstance(element);\n\n\t\tif (!fiber) {\n\t\t\t// Fallback to basic element info if no fiber found\n\t\t\treturn {\n\t\t\t\tcomponentName: element.tagName.toLowerCase(),\n\t\t\t\tprops: {},\n\t\t\t\tsource: null,\n\t\t\t};\n\t\t}\n\n\t\tconst latestFiber = getLatestFiber(fiber);\n\t\tconst componentName =\n\t\t\tgetDisplayName(latestFiber.type) || element.tagName.toLowerCase();\n\t\tconst props = latestFiber.memoizedProps || {};\n\n\t\t// Get source information asynchronously\n\t\tlet source = null;\n\t\ttry {\n\t\t\tsource = await getFiberSource(latestFiber);\n\t\t} catch (sourceError) {\n\t\t\tconsole.warn(\"Failed to get fiber source:\", sourceError);\n\t\t}\n\n\t\treturn {\n\t\t\tcomponentName,\n\t\t\tprops,\n\t\t\tsource,\n\t\t};\n\t} catch (error) {\n\t\tconsole.warn(\"Failed to get fiber info:\", error);\n\t\t// Fallback to basic element info\n\t\treturn {\n\t\t\tcomponentName: element.tagName.toLowerCase(),\n\t\t\tprops: {},\n\t\t\tsource: null,\n\t\t};\n\t}\n};\n\n// Hook for single select annotation\nexport const useSingleSelect = ({ enabled, onAnnotate }: HookProps) => {\n\tconst [element, setElement] = useState<Element | null>(null);\n\tconst [rect, setRect] = useState<DOMRect | null>(null);\n\tconst lastElementRef = useRef<Element | null>(null);\n\tconst onAnnotateRef = useRef(onAnnotate);\n\n\t// Keep onAnnotate ref up to date without triggering effects\n\tuseEffect(() => {\n\t\tonAnnotateRef.current = onAnnotate;\n\t}, [onAnnotate]);\n\n\tuseEffect(() => {\n\t\tif (!enabled) {\n\t\t\tsetElement(null);\n\t\t\tsetRect(null);\n\t\t\tlastElementRef.current = null;\n\t\t\treturn;\n\t\t}\n\n\t\tconst handleMouseMove = throttle((event: MouseEvent) => {\n\t\t\tconst el = document.elementFromPoint(event.clientX, event.clientY);\n\n\t\t\tif (!el || el.closest(\".ai-toolbar-container\")) return;\n\n\t\t\t// Only update if element actually changed\n\t\t\tif (el !== lastElementRef.current) {\n\t\t\t\tlastElementRef.current = el;\n\t\t\t\tsetElement(el);\n\t\t\t\tsetRect(el.getBoundingClientRect());\n\t\t\t}\n\t\t}, 32);\n\n\t\tconst handleClick = async (event: MouseEvent) => {\n\t\t\tconst el = document.elementFromPoint(event.clientX, event.clientY);\n\t\t\tif (!el || el.closest(\".ai-toolbar-container\")) return;\n\n\t\t\tevent.preventDefault();\n\t\t\tevent.stopPropagation();\n\n\t\t\tconst fiberInfo = await getFiberInfo(el);\n\t\t\tif (fiberInfo && onAnnotateRef.current) {\n\t\t\t\tonAnnotateRef.current({\n\t\t\t\t\telement: el,\n\t\t\t\t\trect: el.getBoundingClientRect(),\n\t\t\t\t\tfiberInfo,\n\t\t\t\t\tid: Date.now(),\n\t\t\t\t});\n\t\t\t}\n\t\t};\n\n\t\tdocument.addEventListener(\"mousemove\", handleMouseMove);\n\t\tdocument.addEventListener(\"click\", handleClick, true);\n\n\t\treturn () => {\n\t\t\tdocument.removeEventListener(\"mousemove\", handleMouseMove);\n\t\t\tdocument.removeEventListener(\"click\", handleClick, true);\n\t\t};\n\t}, [enabled]); // Only depend on enabled\n\n\treturn { element, rect };\n};\n\n// Hook for draw select mode\nexport const useDrawSelect = ({ enabled, onAnnotate }: HookProps) => {\n\tconst [isDrawing, setIsDrawing] = useState(false);\n\tconst [startPos, setStartPos] = useState<Position | null>(null);\n\tconst [currentPos, setCurrentPos] = useState<Position | null>(null);\n\tconst [selectedElements, setSelectedElements] = useState<Element[]>([]);\n\tconst onAnnotateRef = useRef(onAnnotate);\n\n\t// Keep onAnnotate ref up to date without triggering effects\n\tuseEffect(() => {\n\t\tonAnnotateRef.current = onAnnotate;\n\t}, [onAnnotate]);\n\n\tuseEffect(() => {\n\t\tif (!enabled) {\n\t\t\tsetIsDrawing(false);\n\t\t\tsetStartPos(null);\n\t\t\tsetCurrentPos(null);\n\t\t\tsetSelectedElements([]);\n\t\t\treturn;\n\t\t}\n\n\t\tconst handleMouseDown = (e: MouseEvent) => {\n\t\t\tif ((e.target as Element)?.closest(\".ai-toolbar-container\")) return;\n\n\t\t\tsetIsDrawing(true);\n\t\t\tconst pos = { x: e.clientX, y: e.clientY };\n\t\t\tsetStartPos(pos);\n\t\t\tsetCurrentPos(pos);\n\t\t};\n\n\t\tconst handleMouseMove = (e: MouseEvent) => {\n\t\t\tif (!isDrawing) return;\n\n\t\t\tconst newPos = { x: e.clientX, y: e.clientY };\n\t\t\tsetCurrentPos(newPos);\n\t\t};\n\n\t\tconst handleMouseUp = async () => {\n\t\t\tif (!isDrawing) return;\n\n\t\t\t// Calculate final selection\n\t\t\tconst rect = getSelectionRect(startPos, currentPos);\n\t\t\tconst elements = rect ? findElementsInRect(rect) : [];\n\n\t\t\tif (elements.length > 0 && onAnnotateRef.current) {\n\t\t\t\tconst fiberInfoPromises = elements.map((el) => getFiberInfo(el));\n\t\t\t\tconst fiberInfoResults = await Promise.all(fiberInfoPromises);\n\t\t\t\tconst fiberInfo = fiberInfoResults.filter(\n\t\t\t\t\t(info): info is FiberInfo => info !== null,\n\t\t\t\t);\n\n\t\t\t\tif (rect) {\n\t\t\t\t\tonAnnotateRef.current({\n\t\t\t\t\t\telements: elements,\n\t\t\t\t\t\trect,\n\t\t\t\t\t\tfiberInfo,\n\t\t\t\t\t\tid: Date.now(),\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tsetIsDrawing(false);\n\t\t\tsetStartPos(null);\n\t\t\tsetCurrentPos(null);\n\t\t\tsetSelectedElements([]);\n\t\t};\n\n\t\tdocument.addEventListener(\"mousedown\", handleMouseDown);\n\t\tdocument.addEventListener(\"mousemove\", handleMouseMove);\n\t\tdocument.addEventListener(\"mouseup\", handleMouseUp);\n\n\t\treturn () => {\n\t\t\tdocument.removeEventListener(\"mousedown\", handleMouseDown);\n\t\t\tdocument.removeEventListener(\"mousemove\", handleMouseMove);\n\t\t\tdocument.removeEventListener(\"mouseup\", handleMouseUp);\n\t\t};\n\t}, [enabled, isDrawing, startPos, currentPos]); // Include drawing state\n\n\t// Update selected elements as user drags\n\tuseEffect(() => {\n\t\tif (!enabled || !isDrawing || !startPos || !currentPos) {\n\t\t\tsetSelectedElements([]);\n\t\t\treturn;\n\t\t}\n\n\t\tconst rect = getSelectionRect(startPos, currentPos);\n\t\tif (rect) {\n\t\t\tconst elements = findElementsInRect(rect);\n\t\t\tsetSelectedElements(elements);\n\t\t}\n\t}, [enabled, isDrawing, startPos, currentPos]);\n\n\treturn { isDrawing, startPos, currentPos, selectedElements };\n};\n\n// Helper functions\nconst getSelectionRect = (\n\tstart: Position | null,\n\tend: Position | null,\n): SelectionRect | null => {\n\tif (!start || !end) return null;\n\treturn {\n\t\tleft: Math.min(start.x, end.x),\n\t\ttop: Math.min(start.y, end.y),\n\t\twidth: Math.abs(end.x - start.x),\n\t\theight: Math.abs(end.y - start.y),\n\t};\n};\n\nconst findElementsInRect = (rect: SelectionRect | null): Element[] => {\n\tif (!rect) return [];\n\tconst elements: Element[] = [];\n\tconst allElements = document.querySelectorAll(\"body *\");\n\n\tallElements.forEach((el) => {\n\t\tif (el.closest(\".ai-toolbar-container\")) return;\n\t\tconst elRect = el.getBoundingClientRect();\n\t\tif (isRectIntersecting(rect, elRect)) {\n\t\t\telements.push(el);\n\t\t}\n\t});\n\n\treturn elements;\n};\n\nconst isRectIntersecting = (rect1: SelectionRect, rect2: DOMRect): boolean => {\n\treturn !(\n\t\trect1.left + rect1.width < rect2.left ||\n\t\trect2.left + rect2.width < rect1.left ||\n\t\trect1.top + rect1.height < rect2.top ||\n\t\trect2.top + rect2.height < rect1.top\n\t);\n};\n",
      "type": "registry:file",
      "target": "components/ai-toolbar/hooks/use-bippy.ts"
    }
  ]
}